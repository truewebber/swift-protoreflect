# Руководство разработчика SwiftProtoReflect

## Важно прочитать сначала!

**ВНИМАНИЕ:** После каждого коммита ты теряешь всю память о проделанной работе. Этот документ поможет тебе быстро восстановить контекст и продолжить разработку.

## Рабочий процесс с учетом потери памяти

1. **Первым делом после возвращения к проекту:**
   - Прочитай файл PROJECT_STATE.md для понимания текущего статуса
   - Проверь секцию "Активные задачи" и "Последние обновления"
   - Запусти `git log -5` чтобы узнать, что было сделано в последних коммитах

2. **Перед началом работы:**
   - Определи задачу из PROJECT_STATE.md
   - Изучи структуру соответствующего модуля и его _README.md
   - Запусти тесты чтобы увидеть, что работает
   - Проверь текущее покрытие кода тестами (`make coverage`)

3. **Во время работы:**
   - Комментируй код так, чтобы твоё "будущее я" могло понять логику
   - Делай небольшие атомарные изменения
   - Обновляй _README.md модуля, над которым работаешь
   - **Стремись к максимальному покрытию кода тестами** - это критически важно для качества библиотеки
     - Достигнутый показатель: 95.82% (превосходно!)
     - Целевой показатель для новых модулей: 90%+ (близко к 100%)
     - Исключения допустимы для путей с `fatalError` или других непроверяемых условий
   - Следуй установленным паттернам проектирования для согласованности кодовой базы
   - Используй Equatable для всех основных типов данных
   - Строго типизируй API, минимизируй использование Any там, где это возможно

4. **Перед каждым коммитом (обязательно!):**
   - Обнови PROJECT_STATE.md, отметив завершенные задачи
   - Запусти `make test && make coverage` и убедись, что все тесты проходят и покрытие кода достаточное
   - Сделай подробное сообщение коммита с префиксом модуля: `[Module] What was done - Why it was done this way - What's next`
   - Запусти `./Scripts/update-state.sh` после коммита для обновления секции "Последние обновления"

## Общие принципы разработки

1. **Дизайн API**
   - Создавай интуитивно понятное API
   - Используй именованные параметры для улучшения читаемости
   - Предпочитай методы с явным именованием, избегай перегрузок методов без явных различий
   - Документируй все публичные API с DocC комментариями

2. **Безопасность типов**
   - Максимально используй систему типов Swift для предотвращения ошибок во время компиляции
   - Явно обрабатывай ошибки через throws/try
   - Ограничивай использование force unwrapping (!) только случаями, когда это абсолютно безопасно

3. **Производительность**
   - Оптимизируй критические участки кода
   - Минимизируй копирование данных там, где это возможно
   - Используй структуры данных, соответствующие характеру операций

4. **Тестирование**
   - Пиши тесты параллельно с кодом, а не после
   - Проверяй крайние случаи и граничные условия
   - Создавай тесты, которые проверяют не только функциональность, но и корректность обработки ошибок

## Структура проекта

- **Sources/SwiftProtoReflect/** - основной код библиотеки:
  - **Descriptor/** - система дескрипторов протобаф сообщений
  - **Dynamic/** - динамическое представление и манипуляция сообщениями
  - **Serialization/** - сериализация/десериализация
  - **Registry/** - централизованное управление типами
  - **Service/** - взаимодействие с gRPC
  - **Bridge/** - интеграция с Swift Protobuf
  - **Errors/** - обработка ошибок

- **Tests/SwiftProtoReflectTests/** - тесты, структура соответствует модулям
  - **Descriptor/** - тесты для системы дескрипторов
  - **Dynamic/** - тесты динамических сообщений
  - **Serialization/** - тесты сериализации
  - **Registry/** - тесты реестра типов
  - **Service/** - тесты сервисных клиентов
  - **Bridge/** - тесты интеграции
  - **Error/** - тесты обработки ошибок
  - **Performance/** - тесты производительности
  - **Compatibility/** - тесты совместимости с Swift Protobuf
  - **TestUtils/** - вспомогательные инструменты для тестирования
  - **Fixtures/** - тестовые данные
  - **Mocks/** - моки для тестирования

## Фазы разработки

### Текущее состояние: Foundation Phase почти завершена ✅

**ЗАВЕРШЕНО:**
- ✅ Descriptor System - полностью реализован (FileDescriptor, MessageDescriptor, FieldDescriptor, EnumDescriptor, ServiceDescriptor)
- ✅ Dynamic Module - полностью реализован (DynamicMessage, MessageFactory, FieldAccessor) 
- ✅ Registry Module - полностью реализован (TypeRegistry, DescriptorPool)

**Общее покрытие тестами: 95.82%** (292 теста проходят)

**СЛЕДУЮЩИЙ ПРИОРИТЕТ:** Serialization Phase
- [ ] Binary format serialization/deserialization
- [ ] JSON format serialization/deserialization  
- [ ] Swift Protobuf integration for serialization

Подробную схему фаз см. в разделе "Предстоящие фазы разработки" в PROJECT_STATE.md

### Рекомендации для начала Serialization Phase

1. **Начать с Binary Serialization:**
   - Создать `BinarySerializer` класс в новом модуле `Serialization`
   - Использовать `swift-protobuf` для низкоуровневых операций сериализации
   - Сначала реализовать сериализацию скалярных типов, затем сложных

2. **Следовать паттернам Foundation Phase:**
   - Высокое покрытие тестами (>90%)
   - Comprehensive error handling
   - DocC документация для всех публичных API
   - Performance тесты для критических путей

3. **Интеграция с существующими компонентами:**
   - Использовать `DynamicMessage` как источник данных
   - Интегрироваться с `TypeRegistry` для разрешения типов
   - Обеспечить совместимость с `DescriptorPool`

## Кодовые соглашения

- Следуй стилю Swift-кода из соседних файлов
- Используй документацию в формате DocC с /// для публичного API
- Добавляй тесты для каждой новой функциональности
- **Требуется высокое покрытие кода тестами** - используй `make coverage` для проверки
  - Недостижимые пути (например, с `fatalError`) могут быть исключены из требования 100% покрытия
  - Важно: добавь комментарий, объясняющий, почему конкретный путь не покрыт тестами

## Тестирование и обработка ошибок

### Структура тестов

Каждый тестовый файл должен содержать:
1. **Тесты инициализации** - проверка корректной инициализации объектов с разными параметрами
2. **Тесты основного функционала** - проверка основных функций и методов
3. **Тесты граничных условий** - проверка поведения в крайних случаях
4. **Тесты ошибок** - проверка корректного выбрасывания ошибок
5. **Тесты производительности** (опционально) - для критичных участков кода

### Тестирование критических сбоев

Некоторые функции используют `fatalError()` для обработки недопустимых состояний, которые не должны возникать при нормальной работе. Эти пути сложно или невозможно протестировать стандартными средствами.

Примеры не тестируемых путей в коде:
- Проверка наличия обязательных параметров в конструкторах
- Валидация типов, которые должны иметь соответствующие имена типов
- Проверка структурной целостности составных объектов

Для таких путей:
1. Добавь четкий комментарий, объясняющий почему случается `fatalError`
2. Используй тесты для проверки корректных случаев использования
3. Используй специальные ожидания (XCTExpectFailure) там, где применимо

### Требования к покрытию кода

Установленный минимальный порог покрытия кода тестами составляет 90%. Для критически важных компонентов следует стремиться к покрытию, близкому к 100%. 

Используйте следующие команды для проверки покрытия:
```bash
make coverage      # Общий отчет о покрытии
```

## Полезные команды

```bash
# Проверка состояния
git log -5                      # Последние 5 коммитов
git diff HEAD~1                 # Что изменилось в последнем коммите

# Разработка
make lint                       # Проверка кода
make format                     # Форматирование кода
swift test                      # Запуск тестов
make coverage                   # Проверка покрытия кода тестами

# Создание новых компонентов
./Scripts/setup-module.sh Descriptor FileDescriptor  # Создает заготовки файлов для нового компонента

# Обновление состояния
./Scripts/update-state.sh       # Обновление PROJECT_STATE.md
```

## Создание новых компонентов

Для быстрого создания заготовок файлов для новых компонентов используй скрипт:

```bash
./Scripts/setup-module.sh <Имя модуля> <Имя компонента>
```

Скрипт автоматически:
- Создаст .swift файл компонента с шаблоном кода в соответствующем модуле
- Создаст файл с тестами для компонента
- Обновит _README.md модуля, добавив новый компонент в список
- Напомнит обновить PROJECT_STATE.md и сделать коммит

Пример:
```bash
./Scripts/setup-module.sh Descriptor FileDescriptor
```

## Работа с Swift Protobuf

Для максимальной совместимости с экосистемой Protobuf, библиотека SwiftProtoReflect опирается на Swift Protobuf для операций низкого уровня:

1. **Сериализация/десериализация**: Для бинарного формата и JSON следует использовать функции Swift Protobuf для совместимости с проверенной реализацией
2. **Проводка типов**: При преобразовании между статическими и динамическими сообщениями обеспечивать корректную валидацию типов
3. **Обработка опций**: Опции должны обрабатываться согласно спецификации Protocol Buffers

## Разрешение проблем и оптимизация

### Циклические ссылки
Компоненты Descriptor System имеют потенциальные циклические ссылки (например, между MessageDescriptor и FieldDescriptor). Для их корректной обработки:
- Используй слабые ссылки (weak) для обратных связей
- Храни только идентификаторы (имена/пути) вместо прямых ссылок на родительские объекты
- Документируй ожидаемый жизненный цикл объектов в комментариях
